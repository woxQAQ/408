# 二叉树

二叉树的特点三每个节点最多有两个子女

区分度为2的树和二叉树：

-度为2的树至少有一个节点的度为2,且树中节点度最大为2
-二叉树是节点的度最多为2,可以没有度为2的节点

二叉树有以下性质：

- 二叉树第i层的节点数最多为$2^{i-1}$个
- 深度为k的二叉树最多有$2^k-1$个节点，最少有$k$个节点
- 对任意非空二叉树，如果其叶节点数为$n_0$,度为2的非叶节点数为$n_2$，则有$n_0=n_2+1$
- n个节点的二叉链表有n+1个空链域（可用于线索化）

## 特殊的二叉树

满二叉树：二叉树的每层都填满节点

![fullBinTree](picture/TREE_fullBinTree.drawio.png)

完全二叉树：每个节点的编号和满二叉树一一对应

![completeBinTree](picture/TREE_completeBinTree.drawio.png)

完全二叉树具有以下特性：

- 深度为h的完全二叉树至少有$2^{h-1}$个节点
- 有n个节点的完全二叉树高度为$\lceil\log_2(n+1)\rceil$
  推导：深度为k的完全二叉树，节点数满足$2^{k-1}-1(前k-1层的总节点数)<n\le2^k-1$可得$k-1<\log_2(n+1)\le k$即$k=\lceil\log_2(n+1)\rceil$
- 对于编号为$i$的节点，若其有左子树$(2i\le n)$，其左孩子编号为$2i$,若其有右子树$(2i+1\le n)$，其右孩子编号为$2i+1$。父节点编号$[i/2]$
  
## 二叉树的存储结构

### 顺序存储

对于**完全二叉树**和**满二叉树**而言，顺序存储是最简单，最节省存储的存储结构。只需定义一个一维数组，将**完全二叉树**和**满二叉树**按照顺序写成一个线性序列放入一维数组即可。
![seqStorage](picture/TREE_sequentStorage.drawio.png)

对于普通的二叉树，为了体现出二叉树的逻辑结构，节点必须按照存储满二叉树那样进行编号，写成线性序列，空节点则假定为没有元素的节点也进行编号，然后进行存储。这样会浪费大量的存储空间.故对于一般的二叉树，我们采用二叉链表存储

### 链式存储（二叉链表）


~~~c
typedef struct BiTNode{
    int data;
    BinNode *lchild, *rchild;
}BitNode, *BiTree
~~~

![linkStorage](picture/TREE_binNodeStorage.drawio.png)

# 二叉树的遍历(重点)

> 近年来，对二叉树遍历的考察频率降低，但在408越来越重视树，图这类算法的趋势下，这块内容还是很有可能出题的

二叉树有三种遍历方式：前序遍历，中序遍历，后序遍历

所谓的前中后，是指这三种遍历对根节点的访问优先度

前序遍历先访问根节点，再访问左子树，最后访问右子树。对每颗子树的访问也遵循这个顺序

~~~c
  void preOrder(BiTree T){
    if(T!=NULL){//不为空树，访问
      visit(T);//自定义的访问函数
      preOrder(T->lchild);//遍历左子树
      preOrder(T->rchild);//遍历右子树
    }
  }
~~~

中序遍历先访问左子树，再访问根节点，最后访问右子树。对每颗子树的访问也遵循这个顺序

~~~c
  void inOrder(BiTree T){
    if(T!=NULL){//不为空树，访问
      inOrder(T->lchild);//遍历左子树
      visit(T);//自定义的访问函数
      inOrder(T->rchild);//遍历右子树
    }
  }
~~~

后序遍历先访问右子树，再访问左子树，最后访问根节点。对每颗子树的访问也遵循这个顺序

~~~c
  void postOrder(BiTree T){
    if(T!=NULL){//不为空树，访问
      postOrder(T->lchild);//遍历左子树
      postOrder(T->rchild);//遍历右子树
      visit(T);//自定义的访问函数
    }
  }
~~~

值得注意的是，若使用二叉树表示表达式，利用前序，中序，后序遍历可以分别得到前缀表达式，中缀表达式，后缀表达式

## 二叉树，栈的应用之计算机中的表达式求值

在小学时，我们便学过如何进行四则运算，大概遵循**从左到右，先乘除后加减，括号内先算**的原则，下面是一个很常见的算术表达式

$((15\div(7-(1+1)))\times3)-(2+(1+1))$

其中我们定义：

- 界限符：‘(',')'
- 操作数：数字
- 运算符：加减乘除
上面的表达式就是我们所说的**中缀表达式**，在数学中，还有**后缀表达式**和**前缀表达式**

前缀表达式即运算符放在两个操作数前面

后缀表达式即运算符放在两个操作数后面，如$1+1的后缀表达式就是11+$，这种表达式对于人类来说似乎一头雾水，但对于计算机运算而言非常方便（后文会讲述）

表达式的二叉树表达如下

![RPN](picture/stack_RPN.drawio.png)


那么，给定一个中缀表达式，如何转化为后缀表达式？

### 中缀表达式转化为后缀表达式

中缀表达式转化为后缀表达式的步骤如下：

1. 确定运算顺序
   $((15\div(7-(1+1)))\times3)-(2+(1+1))$
2. 